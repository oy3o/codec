// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

//go:build test

package codec

import (
	"io"

	mock "github.com/stretchr/testify/mock"
)

// NewMockSizer creates a new instance of MockSizer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSizer(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSizer {
	mock := &MockSizer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSizer is an autogenerated mock type for the Sizer type
type MockSizer struct {
	mock.Mock
}

type MockSizer_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSizer) EXPECT() *MockSizer_Expecter {
	return &MockSizer_Expecter{mock: &_m.Mock}
}

// Size provides a mock function for the type MockSizer
func (_mock *MockSizer) Size() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// MockSizer_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type MockSizer_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *MockSizer_Expecter) Size() *MockSizer_Size_Call {
	return &MockSizer_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *MockSizer_Size_Call) Run(run func()) *MockSizer_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockSizer_Size_Call) Return(n int) *MockSizer_Size_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MockSizer_Size_Call) RunAndReturn(run func() int) *MockSizer_Size_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMarshaler creates a new instance of MockMarshaler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMarshaler(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMarshaler {
	mock := &MockMarshaler{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMarshaler is an autogenerated mock type for the Marshaler type
type MockMarshaler struct {
	mock.Mock
}

type MockMarshaler_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMarshaler) EXPECT() *MockMarshaler_Expecter {
	return &MockMarshaler_Expecter{mock: &_m.Mock}
}

// MarshalBinary provides a mock function for the type MockMarshaler
func (_mock *MockMarshaler) MarshalBinary() ([]byte, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for MarshalBinary")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]byte, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []byte); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMarshaler_MarshalBinary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarshalBinary'
type MockMarshaler_MarshalBinary_Call struct {
	*mock.Call
}

// MarshalBinary is a helper method to define mock.On call
func (_e *MockMarshaler_Expecter) MarshalBinary() *MockMarshaler_MarshalBinary_Call {
	return &MockMarshaler_MarshalBinary_Call{Call: _e.mock.On("MarshalBinary")}
}

func (_c *MockMarshaler_MarshalBinary_Call) Run(run func()) *MockMarshaler_MarshalBinary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockMarshaler_MarshalBinary_Call) Return(data []byte, err error) *MockMarshaler_MarshalBinary_Call {
	_c.Call.Return(data, err)
	return _c
}

func (_c *MockMarshaler_MarshalBinary_Call) RunAndReturn(run func() ([]byte, error)) *MockMarshaler_MarshalBinary_Call {
	_c.Call.Return(run)
	return _c
}

// MarshalTo provides a mock function for the type MockMarshaler
func (_mock *MockMarshaler) MarshalTo(buf []byte) (int, error) {
	ret := _mock.Called(buf)

	if len(ret) == 0 {
		panic("no return value specified for MarshalTo")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(buf)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(buf)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(buf)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMarshaler_MarshalTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarshalTo'
type MockMarshaler_MarshalTo_Call struct {
	*mock.Call
}

// MarshalTo is a helper method to define mock.On call
//   - buf []byte
func (_e *MockMarshaler_Expecter) MarshalTo(buf interface{}) *MockMarshaler_MarshalTo_Call {
	return &MockMarshaler_MarshalTo_Call{Call: _e.mock.On("MarshalTo", buf)}
}

func (_c *MockMarshaler_MarshalTo_Call) Run(run func(buf []byte)) *MockMarshaler_MarshalTo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockMarshaler_MarshalTo_Call) Return(n int, err error) *MockMarshaler_MarshalTo_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockMarshaler_MarshalTo_Call) RunAndReturn(run func(buf []byte) (int, error)) *MockMarshaler_MarshalTo_Call {
	_c.Call.Return(run)
	return _c
}

// WriteTo provides a mock function for the type MockMarshaler
func (_mock *MockMarshaler) WriteTo(w io.Writer) (int64, error) {
	ret := _mock.Called(w)

	if len(ret) == 0 {
		panic("no return value specified for WriteTo")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(io.Writer) (int64, error)); ok {
		return returnFunc(w)
	}
	if returnFunc, ok := ret.Get(0).(func(io.Writer) int64); ok {
		r0 = returnFunc(w)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(io.Writer) error); ok {
		r1 = returnFunc(w)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMarshaler_WriteTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteTo'
type MockMarshaler_WriteTo_Call struct {
	*mock.Call
}

// WriteTo is a helper method to define mock.On call
//   - w io.Writer
func (_e *MockMarshaler_Expecter) WriteTo(w interface{}) *MockMarshaler_WriteTo_Call {
	return &MockMarshaler_WriteTo_Call{Call: _e.mock.On("WriteTo", w)}
}

func (_c *MockMarshaler_WriteTo_Call) Run(run func(w io.Writer)) *MockMarshaler_WriteTo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 io.Writer
		if args[0] != nil {
			arg0 = args[0].(io.Writer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockMarshaler_WriteTo_Call) Return(n int64, err error) *MockMarshaler_WriteTo_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockMarshaler_WriteTo_Call) RunAndReturn(run func(w io.Writer) (int64, error)) *MockMarshaler_WriteTo_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUnmarshaler creates a new instance of MockUnmarshaler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUnmarshaler(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUnmarshaler {
	mock := &MockUnmarshaler{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUnmarshaler is an autogenerated mock type for the Unmarshaler type
type MockUnmarshaler struct {
	mock.Mock
}

type MockUnmarshaler_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUnmarshaler) EXPECT() *MockUnmarshaler_Expecter {
	return &MockUnmarshaler_Expecter{mock: &_m.Mock}
}

// ReadFrom provides a mock function for the type MockUnmarshaler
func (_mock *MockUnmarshaler) ReadFrom(r io.Reader) (int64, error) {
	ret := _mock.Called(r)

	if len(ret) == 0 {
		panic("no return value specified for ReadFrom")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(io.Reader) (int64, error)); ok {
		return returnFunc(r)
	}
	if returnFunc, ok := ret.Get(0).(func(io.Reader) int64); ok {
		r0 = returnFunc(r)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(io.Reader) error); ok {
		r1 = returnFunc(r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUnmarshaler_ReadFrom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadFrom'
type MockUnmarshaler_ReadFrom_Call struct {
	*mock.Call
}

// ReadFrom is a helper method to define mock.On call
//   - r io.Reader
func (_e *MockUnmarshaler_Expecter) ReadFrom(r interface{}) *MockUnmarshaler_ReadFrom_Call {
	return &MockUnmarshaler_ReadFrom_Call{Call: _e.mock.On("ReadFrom", r)}
}

func (_c *MockUnmarshaler_ReadFrom_Call) Run(run func(r io.Reader)) *MockUnmarshaler_ReadFrom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 io.Reader
		if args[0] != nil {
			arg0 = args[0].(io.Reader)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockUnmarshaler_ReadFrom_Call) Return(n int64, err error) *MockUnmarshaler_ReadFrom_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockUnmarshaler_ReadFrom_Call) RunAndReturn(run func(r io.Reader) (int64, error)) *MockUnmarshaler_ReadFrom_Call {
	_c.Call.Return(run)
	return _c
}

// UnmarshalBinary provides a mock function for the type MockUnmarshaler
func (_mock *MockUnmarshaler) UnmarshalBinary(data []byte) error {
	ret := _mock.Called(data)

	if len(ret) == 0 {
		panic("no return value specified for UnmarshalBinary")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = returnFunc(data)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUnmarshaler_UnmarshalBinary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnmarshalBinary'
type MockUnmarshaler_UnmarshalBinary_Call struct {
	*mock.Call
}

// UnmarshalBinary is a helper method to define mock.On call
//   - data []byte
func (_e *MockUnmarshaler_Expecter) UnmarshalBinary(data interface{}) *MockUnmarshaler_UnmarshalBinary_Call {
	return &MockUnmarshaler_UnmarshalBinary_Call{Call: _e.mock.On("UnmarshalBinary", data)}
}

func (_c *MockUnmarshaler_UnmarshalBinary_Call) Run(run func(data []byte)) *MockUnmarshaler_UnmarshalBinary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockUnmarshaler_UnmarshalBinary_Call) Return(err error) *MockUnmarshaler_UnmarshalBinary_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUnmarshaler_UnmarshalBinary_Call) RunAndReturn(run func(data []byte) error) *MockUnmarshaler_UnmarshalBinary_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockCodec creates a new instance of MockCodec. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCodec(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCodec {
	mock := &MockCodec{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockCodec is an autogenerated mock type for the Codec type
type MockCodec struct {
	mock.Mock
}

type MockCodec_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCodec) EXPECT() *MockCodec_Expecter {
	return &MockCodec_Expecter{mock: &_m.Mock}
}

// MarshalBinary provides a mock function for the type MockCodec
func (_mock *MockCodec) MarshalBinary() ([]byte, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for MarshalBinary")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]byte, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []byte); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCodec_MarshalBinary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarshalBinary'
type MockCodec_MarshalBinary_Call struct {
	*mock.Call
}

// MarshalBinary is a helper method to define mock.On call
func (_e *MockCodec_Expecter) MarshalBinary() *MockCodec_MarshalBinary_Call {
	return &MockCodec_MarshalBinary_Call{Call: _e.mock.On("MarshalBinary")}
}

func (_c *MockCodec_MarshalBinary_Call) Run(run func()) *MockCodec_MarshalBinary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockCodec_MarshalBinary_Call) Return(data []byte, err error) *MockCodec_MarshalBinary_Call {
	_c.Call.Return(data, err)
	return _c
}

func (_c *MockCodec_MarshalBinary_Call) RunAndReturn(run func() ([]byte, error)) *MockCodec_MarshalBinary_Call {
	_c.Call.Return(run)
	return _c
}

// MarshalTo provides a mock function for the type MockCodec
func (_mock *MockCodec) MarshalTo(buf []byte) (int, error) {
	ret := _mock.Called(buf)

	if len(ret) == 0 {
		panic("no return value specified for MarshalTo")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(buf)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(buf)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(buf)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCodec_MarshalTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarshalTo'
type MockCodec_MarshalTo_Call struct {
	*mock.Call
}

// MarshalTo is a helper method to define mock.On call
//   - buf []byte
func (_e *MockCodec_Expecter) MarshalTo(buf interface{}) *MockCodec_MarshalTo_Call {
	return &MockCodec_MarshalTo_Call{Call: _e.mock.On("MarshalTo", buf)}
}

func (_c *MockCodec_MarshalTo_Call) Run(run func(buf []byte)) *MockCodec_MarshalTo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockCodec_MarshalTo_Call) Return(n int, err error) *MockCodec_MarshalTo_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockCodec_MarshalTo_Call) RunAndReturn(run func(buf []byte) (int, error)) *MockCodec_MarshalTo_Call {
	_c.Call.Return(run)
	return _c
}

// ReadFrom provides a mock function for the type MockCodec
func (_mock *MockCodec) ReadFrom(r io.Reader) (int64, error) {
	ret := _mock.Called(r)

	if len(ret) == 0 {
		panic("no return value specified for ReadFrom")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(io.Reader) (int64, error)); ok {
		return returnFunc(r)
	}
	if returnFunc, ok := ret.Get(0).(func(io.Reader) int64); ok {
		r0 = returnFunc(r)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(io.Reader) error); ok {
		r1 = returnFunc(r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCodec_ReadFrom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadFrom'
type MockCodec_ReadFrom_Call struct {
	*mock.Call
}

// ReadFrom is a helper method to define mock.On call
//   - r io.Reader
func (_e *MockCodec_Expecter) ReadFrom(r interface{}) *MockCodec_ReadFrom_Call {
	return &MockCodec_ReadFrom_Call{Call: _e.mock.On("ReadFrom", r)}
}

func (_c *MockCodec_ReadFrom_Call) Run(run func(r io.Reader)) *MockCodec_ReadFrom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 io.Reader
		if args[0] != nil {
			arg0 = args[0].(io.Reader)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockCodec_ReadFrom_Call) Return(n int64, err error) *MockCodec_ReadFrom_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockCodec_ReadFrom_Call) RunAndReturn(run func(r io.Reader) (int64, error)) *MockCodec_ReadFrom_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type MockCodec
func (_mock *MockCodec) Size() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// MockCodec_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type MockCodec_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *MockCodec_Expecter) Size() *MockCodec_Size_Call {
	return &MockCodec_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *MockCodec_Size_Call) Run(run func()) *MockCodec_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockCodec_Size_Call) Return(n int) *MockCodec_Size_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MockCodec_Size_Call) RunAndReturn(run func() int) *MockCodec_Size_Call {
	_c.Call.Return(run)
	return _c
}

// UnmarshalBinary provides a mock function for the type MockCodec
func (_mock *MockCodec) UnmarshalBinary(data []byte) error {
	ret := _mock.Called(data)

	if len(ret) == 0 {
		panic("no return value specified for UnmarshalBinary")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = returnFunc(data)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCodec_UnmarshalBinary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnmarshalBinary'
type MockCodec_UnmarshalBinary_Call struct {
	*mock.Call
}

// UnmarshalBinary is a helper method to define mock.On call
//   - data []byte
func (_e *MockCodec_Expecter) UnmarshalBinary(data interface{}) *MockCodec_UnmarshalBinary_Call {
	return &MockCodec_UnmarshalBinary_Call{Call: _e.mock.On("UnmarshalBinary", data)}
}

func (_c *MockCodec_UnmarshalBinary_Call) Run(run func(data []byte)) *MockCodec_UnmarshalBinary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockCodec_UnmarshalBinary_Call) Return(err error) *MockCodec_UnmarshalBinary_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCodec_UnmarshalBinary_Call) RunAndReturn(run func(data []byte) error) *MockCodec_UnmarshalBinary_Call {
	_c.Call.Return(run)
	return _c
}

// WriteTo provides a mock function for the type MockCodec
func (_mock *MockCodec) WriteTo(w io.Writer) (int64, error) {
	ret := _mock.Called(w)

	if len(ret) == 0 {
		panic("no return value specified for WriteTo")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(io.Writer) (int64, error)); ok {
		return returnFunc(w)
	}
	if returnFunc, ok := ret.Get(0).(func(io.Writer) int64); ok {
		r0 = returnFunc(w)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(io.Writer) error); ok {
		r1 = returnFunc(w)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCodec_WriteTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteTo'
type MockCodec_WriteTo_Call struct {
	*mock.Call
}

// WriteTo is a helper method to define mock.On call
//   - w io.Writer
func (_e *MockCodec_Expecter) WriteTo(w interface{}) *MockCodec_WriteTo_Call {
	return &MockCodec_WriteTo_Call{Call: _e.mock.On("WriteTo", w)}
}

func (_c *MockCodec_WriteTo_Call) Run(run func(w io.Writer)) *MockCodec_WriteTo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 io.Writer
		if args[0] != nil {
			arg0 = args[0].(io.Writer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockCodec_WriteTo_Call) Return(n int64, err error) *MockCodec_WriteTo_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockCodec_WriteTo_Call) RunAndReturn(run func(w io.Writer) (int64, error)) *MockCodec_WriteTo_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockList creates a new instance of MockList. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockList(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockList {
	mock := &MockList{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockList is an autogenerated mock type for the List type
type MockList struct {
	mock.Mock
}

type MockList_Expecter struct {
	mock *mock.Mock
}

func (_m *MockList) EXPECT() *MockList_Expecter {
	return &MockList_Expecter{mock: &_m.Mock}
}

// Codecs provides a mock function for the type MockList
func (_mock *MockList) Codecs() []Codec {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Codecs")
	}

	var r0 []Codec
	if returnFunc, ok := ret.Get(0).(func() []Codec); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Codec)
		}
	}
	return r0
}

// MockList_Codecs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Codecs'
type MockList_Codecs_Call struct {
	*mock.Call
}

// Codecs is a helper method to define mock.On call
func (_e *MockList_Expecter) Codecs() *MockList_Codecs_Call {
	return &MockList_Codecs_Call{Call: _e.mock.On("Codecs")}
}

func (_c *MockList_Codecs_Call) Run(run func()) *MockList_Codecs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockList_Codecs_Call) Return(codecs []Codec) *MockList_Codecs_Call {
	_c.Call.Return(codecs)
	return _c
}

func (_c *MockList_Codecs_Call) RunAndReturn(run func() []Codec) *MockList_Codecs_Call {
	_c.Call.Return(run)
	return _c
}

// Len provides a mock function for the type MockList
func (_mock *MockList) Len() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Len")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// MockList_Len_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Len'
type MockList_Len_Call struct {
	*mock.Call
}

// Len is a helper method to define mock.On call
func (_e *MockList_Expecter) Len() *MockList_Len_Call {
	return &MockList_Len_Call{Call: _e.mock.On("Len")}
}

func (_c *MockList_Len_Call) Run(run func()) *MockList_Len_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockList_Len_Call) Return(n int) *MockList_Len_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MockList_Len_Call) RunAndReturn(run func() int) *MockList_Len_Call {
	_c.Call.Return(run)
	return _c
}

// MarshalBinary provides a mock function for the type MockList
func (_mock *MockList) MarshalBinary() ([]byte, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for MarshalBinary")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]byte, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []byte); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockList_MarshalBinary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarshalBinary'
type MockList_MarshalBinary_Call struct {
	*mock.Call
}

// MarshalBinary is a helper method to define mock.On call
func (_e *MockList_Expecter) MarshalBinary() *MockList_MarshalBinary_Call {
	return &MockList_MarshalBinary_Call{Call: _e.mock.On("MarshalBinary")}
}

func (_c *MockList_MarshalBinary_Call) Run(run func()) *MockList_MarshalBinary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockList_MarshalBinary_Call) Return(data []byte, err error) *MockList_MarshalBinary_Call {
	_c.Call.Return(data, err)
	return _c
}

func (_c *MockList_MarshalBinary_Call) RunAndReturn(run func() ([]byte, error)) *MockList_MarshalBinary_Call {
	_c.Call.Return(run)
	return _c
}

// MarshalTo provides a mock function for the type MockList
func (_mock *MockList) MarshalTo(buf []byte) (int, error) {
	ret := _mock.Called(buf)

	if len(ret) == 0 {
		panic("no return value specified for MarshalTo")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(buf)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(buf)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(buf)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockList_MarshalTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarshalTo'
type MockList_MarshalTo_Call struct {
	*mock.Call
}

// MarshalTo is a helper method to define mock.On call
//   - buf []byte
func (_e *MockList_Expecter) MarshalTo(buf interface{}) *MockList_MarshalTo_Call {
	return &MockList_MarshalTo_Call{Call: _e.mock.On("MarshalTo", buf)}
}

func (_c *MockList_MarshalTo_Call) Run(run func(buf []byte)) *MockList_MarshalTo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockList_MarshalTo_Call) Return(n int, err error) *MockList_MarshalTo_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockList_MarshalTo_Call) RunAndReturn(run func(buf []byte) (int, error)) *MockList_MarshalTo_Call {
	_c.Call.Return(run)
	return _c
}

// ReadFrom provides a mock function for the type MockList
func (_mock *MockList) ReadFrom(r io.Reader) (int64, error) {
	ret := _mock.Called(r)

	if len(ret) == 0 {
		panic("no return value specified for ReadFrom")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(io.Reader) (int64, error)); ok {
		return returnFunc(r)
	}
	if returnFunc, ok := ret.Get(0).(func(io.Reader) int64); ok {
		r0 = returnFunc(r)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(io.Reader) error); ok {
		r1 = returnFunc(r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockList_ReadFrom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadFrom'
type MockList_ReadFrom_Call struct {
	*mock.Call
}

// ReadFrom is a helper method to define mock.On call
//   - r io.Reader
func (_e *MockList_Expecter) ReadFrom(r interface{}) *MockList_ReadFrom_Call {
	return &MockList_ReadFrom_Call{Call: _e.mock.On("ReadFrom", r)}
}

func (_c *MockList_ReadFrom_Call) Run(run func(r io.Reader)) *MockList_ReadFrom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 io.Reader
		if args[0] != nil {
			arg0 = args[0].(io.Reader)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockList_ReadFrom_Call) Return(n int64, err error) *MockList_ReadFrom_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockList_ReadFrom_Call) RunAndReturn(run func(r io.Reader) (int64, error)) *MockList_ReadFrom_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type MockList
func (_mock *MockList) Size() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// MockList_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type MockList_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *MockList_Expecter) Size() *MockList_Size_Call {
	return &MockList_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *MockList_Size_Call) Run(run func()) *MockList_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockList_Size_Call) Return(n int) *MockList_Size_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MockList_Size_Call) RunAndReturn(run func() int) *MockList_Size_Call {
	_c.Call.Return(run)
	return _c
}

// UnmarshalBinary provides a mock function for the type MockList
func (_mock *MockList) UnmarshalBinary(data []byte) error {
	ret := _mock.Called(data)

	if len(ret) == 0 {
		panic("no return value specified for UnmarshalBinary")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = returnFunc(data)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockList_UnmarshalBinary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnmarshalBinary'
type MockList_UnmarshalBinary_Call struct {
	*mock.Call
}

// UnmarshalBinary is a helper method to define mock.On call
//   - data []byte
func (_e *MockList_Expecter) UnmarshalBinary(data interface{}) *MockList_UnmarshalBinary_Call {
	return &MockList_UnmarshalBinary_Call{Call: _e.mock.On("UnmarshalBinary", data)}
}

func (_c *MockList_UnmarshalBinary_Call) Run(run func(data []byte)) *MockList_UnmarshalBinary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockList_UnmarshalBinary_Call) Return(err error) *MockList_UnmarshalBinary_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockList_UnmarshalBinary_Call) RunAndReturn(run func(data []byte) error) *MockList_UnmarshalBinary_Call {
	_c.Call.Return(run)
	return _c
}

// WriteTo provides a mock function for the type MockList
func (_mock *MockList) WriteTo(w io.Writer) (int64, error) {
	ret := _mock.Called(w)

	if len(ret) == 0 {
		panic("no return value specified for WriteTo")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(io.Writer) (int64, error)); ok {
		return returnFunc(w)
	}
	if returnFunc, ok := ret.Get(0).(func(io.Writer) int64); ok {
		r0 = returnFunc(w)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(io.Writer) error); ok {
		r1 = returnFunc(w)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockList_WriteTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteTo'
type MockList_WriteTo_Call struct {
	*mock.Call
}

// WriteTo is a helper method to define mock.On call
//   - w io.Writer
func (_e *MockList_Expecter) WriteTo(w interface{}) *MockList_WriteTo_Call {
	return &MockList_WriteTo_Call{Call: _e.mock.On("WriteTo", w)}
}

func (_c *MockList_WriteTo_Call) Run(run func(w io.Writer)) *MockList_WriteTo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 io.Writer
		if args[0] != nil {
			arg0 = args[0].(io.Writer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockList_WriteTo_Call) Return(n int64, err error) *MockList_WriteTo_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockList_WriteTo_Call) RunAndReturn(run func(w io.Writer) (int64, error)) *MockList_WriteTo_Call {
	_c.Call.Return(run)
	return _c
}

// newMockreader creates a new instance of mockreader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockreader(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockreader {
	mock := &mockreader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mockreader is an autogenerated mock type for the reader type
type mockreader struct {
	mock.Mock
}

type mockreader_Expecter struct {
	mock *mock.Mock
}

func (_m *mockreader) EXPECT() *mockreader_Expecter {
	return &mockreader_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type mockreader
func (_mock *mockreader) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mockreader_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type mockreader_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *mockreader_Expecter) Close() *mockreader_Close_Call {
	return &mockreader_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *mockreader_Close_Call) Run(run func()) *mockreader_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *mockreader_Close_Call) Return(err error) *mockreader_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mockreader_Close_Call) RunAndReturn(run func() error) *mockreader_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Read provides a mock function for the type mockreader
func (_mock *mockreader) Read(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Read")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockreader_Read_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Read'
type mockreader_Read_Call struct {
	*mock.Call
}

// Read is a helper method to define mock.On call
//   - p []byte
func (_e *mockreader_Expecter) Read(p interface{}) *mockreader_Read_Call {
	return &mockreader_Read_Call{Call: _e.mock.On("Read", p)}
}

func (_c *mockreader_Read_Call) Run(run func(p []byte)) *mockreader_Read_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mockreader_Read_Call) Return(n int, err error) *mockreader_Read_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *mockreader_Read_Call) RunAndReturn(run func(p []byte) (int, error)) *mockreader_Read_Call {
	_c.Call.Return(run)
	return _c
}

// WriteTo provides a mock function for the type mockreader
func (_mock *mockreader) WriteTo(w io.Writer) (int64, error) {
	ret := _mock.Called(w)

	if len(ret) == 0 {
		panic("no return value specified for WriteTo")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(io.Writer) (int64, error)); ok {
		return returnFunc(w)
	}
	if returnFunc, ok := ret.Get(0).(func(io.Writer) int64); ok {
		r0 = returnFunc(w)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(io.Writer) error); ok {
		r1 = returnFunc(w)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockreader_WriteTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteTo'
type mockreader_WriteTo_Call struct {
	*mock.Call
}

// WriteTo is a helper method to define mock.On call
//   - w io.Writer
func (_e *mockreader_Expecter) WriteTo(w interface{}) *mockreader_WriteTo_Call {
	return &mockreader_WriteTo_Call{Call: _e.mock.On("WriteTo", w)}
}

func (_c *mockreader_WriteTo_Call) Run(run func(w io.Writer)) *mockreader_WriteTo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 io.Writer
		if args[0] != nil {
			arg0 = args[0].(io.Writer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mockreader_WriteTo_Call) Return(n int64, err error) *mockreader_WriteTo_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *mockreader_WriteTo_Call) RunAndReturn(run func(w io.Writer) (int64, error)) *mockreader_WriteTo_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockReaderPro creates a new instance of MockReaderPro. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockReaderPro(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockReaderPro {
	mock := &MockReaderPro{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockReaderPro is an autogenerated mock type for the ReaderPro type
type MockReaderPro struct {
	mock.Mock
}

type MockReaderPro_Expecter struct {
	mock *mock.Mock
}

func (_m *MockReaderPro) EXPECT() *MockReaderPro_Expecter {
	return &MockReaderPro_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type MockReaderPro
func (_mock *MockReaderPro) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockReaderPro_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockReaderPro_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockReaderPro_Expecter) Close() *MockReaderPro_Close_Call {
	return &MockReaderPro_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockReaderPro_Close_Call) Run(run func()) *MockReaderPro_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockReaderPro_Close_Call) Return(err error) *MockReaderPro_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockReaderPro_Close_Call) RunAndReturn(run func() error) *MockReaderPro_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Read provides a mock function for the type MockReaderPro
func (_mock *MockReaderPro) Read(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Read")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReaderPro_Read_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Read'
type MockReaderPro_Read_Call struct {
	*mock.Call
}

// Read is a helper method to define mock.On call
//   - p []byte
func (_e *MockReaderPro_Expecter) Read(p interface{}) *MockReaderPro_Read_Call {
	return &MockReaderPro_Read_Call{Call: _e.mock.On("Read", p)}
}

func (_c *MockReaderPro_Read_Call) Run(run func(p []byte)) *MockReaderPro_Read_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockReaderPro_Read_Call) Return(n int, err error) *MockReaderPro_Read_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReaderPro_Read_Call) RunAndReturn(run func(p []byte) (int, error)) *MockReaderPro_Read_Call {
	_c.Call.Return(run)
	return _c
}

// ReadByte provides a mock function for the type MockReaderPro
func (_mock *MockReaderPro) ReadByte() (byte, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ReadByte")
	}

	var r0 byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (byte, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() byte); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(byte)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReaderPro_ReadByte_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadByte'
type MockReaderPro_ReadByte_Call struct {
	*mock.Call
}

// ReadByte is a helper method to define mock.On call
func (_e *MockReaderPro_Expecter) ReadByte() *MockReaderPro_ReadByte_Call {
	return &MockReaderPro_ReadByte_Call{Call: _e.mock.On("ReadByte")}
}

func (_c *MockReaderPro_ReadByte_Call) Run(run func()) *MockReaderPro_ReadByte_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockReaderPro_ReadByte_Call) Return(v byte, err error) *MockReaderPro_ReadByte_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockReaderPro_ReadByte_Call) RunAndReturn(run func() (byte, error)) *MockReaderPro_ReadByte_Call {
	_c.Call.Return(run)
	return _c
}

// Seek provides a mock function for the type MockReaderPro
func (_mock *MockReaderPro) Seek(offset int64, whence int) (int64, error) {
	ret := _mock.Called(offset, whence)

	if len(ret) == 0 {
		panic("no return value specified for Seek")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64, int) (int64, error)); ok {
		return returnFunc(offset, whence)
	}
	if returnFunc, ok := ret.Get(0).(func(int64, int) int64); ok {
		r0 = returnFunc(offset, whence)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(int64, int) error); ok {
		r1 = returnFunc(offset, whence)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReaderPro_Seek_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Seek'
type MockReaderPro_Seek_Call struct {
	*mock.Call
}

// Seek is a helper method to define mock.On call
//   - offset int64
//   - whence int
func (_e *MockReaderPro_Expecter) Seek(offset interface{}, whence interface{}) *MockReaderPro_Seek_Call {
	return &MockReaderPro_Seek_Call{Call: _e.mock.On("Seek", offset, whence)}
}

func (_c *MockReaderPro_Seek_Call) Run(run func(offset int64, whence int)) *MockReaderPro_Seek_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockReaderPro_Seek_Call) Return(n int64, err error) *MockReaderPro_Seek_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReaderPro_Seek_Call) RunAndReturn(run func(offset int64, whence int) (int64, error)) *MockReaderPro_Seek_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type MockReaderPro
func (_mock *MockReaderPro) Size() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// MockReaderPro_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type MockReaderPro_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *MockReaderPro_Expecter) Size() *MockReaderPro_Size_Call {
	return &MockReaderPro_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *MockReaderPro_Size_Call) Run(run func()) *MockReaderPro_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockReaderPro_Size_Call) Return(n int) *MockReaderPro_Size_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MockReaderPro_Size_Call) RunAndReturn(run func() int) *MockReaderPro_Size_Call {
	_c.Call.Return(run)
	return _c
}

// WriteTo provides a mock function for the type MockReaderPro
func (_mock *MockReaderPro) WriteTo(w io.Writer) (int64, error) {
	ret := _mock.Called(w)

	if len(ret) == 0 {
		panic("no return value specified for WriteTo")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(io.Writer) (int64, error)); ok {
		return returnFunc(w)
	}
	if returnFunc, ok := ret.Get(0).(func(io.Writer) int64); ok {
		r0 = returnFunc(w)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(io.Writer) error); ok {
		r1 = returnFunc(w)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReaderPro_WriteTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteTo'
type MockReaderPro_WriteTo_Call struct {
	*mock.Call
}

// WriteTo is a helper method to define mock.On call
//   - w io.Writer
func (_e *MockReaderPro_Expecter) WriteTo(w interface{}) *MockReaderPro_WriteTo_Call {
	return &MockReaderPro_WriteTo_Call{Call: _e.mock.On("WriteTo", w)}
}

func (_c *MockReaderPro_WriteTo_Call) Run(run func(w io.Writer)) *MockReaderPro_WriteTo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 io.Writer
		if args[0] != nil {
			arg0 = args[0].(io.Writer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockReaderPro_WriteTo_Call) Return(n int64, err error) *MockReaderPro_WriteTo_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReaderPro_WriteTo_Call) RunAndReturn(run func(w io.Writer) (int64, error)) *MockReaderPro_WriteTo_Call {
	_c.Call.Return(run)
	return _c
}

// newMockwriter creates a new instance of mockwriter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockwriter(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockwriter {
	mock := &mockwriter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mockwriter is an autogenerated mock type for the writer type
type mockwriter struct {
	mock.Mock
}

type mockwriter_Expecter struct {
	mock *mock.Mock
}

func (_m *mockwriter) EXPECT() *mockwriter_Expecter {
	return &mockwriter_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type mockwriter
func (_mock *mockwriter) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mockwriter_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type mockwriter_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *mockwriter_Expecter) Close() *mockwriter_Close_Call {
	return &mockwriter_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *mockwriter_Close_Call) Run(run func()) *mockwriter_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *mockwriter_Close_Call) Return(err error) *mockwriter_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mockwriter_Close_Call) RunAndReturn(run func() error) *mockwriter_Close_Call {
	_c.Call.Return(run)
	return _c
}

// ReadFrom provides a mock function for the type mockwriter
func (_mock *mockwriter) ReadFrom(r io.Reader) (int64, error) {
	ret := _mock.Called(r)

	if len(ret) == 0 {
		panic("no return value specified for ReadFrom")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(io.Reader) (int64, error)); ok {
		return returnFunc(r)
	}
	if returnFunc, ok := ret.Get(0).(func(io.Reader) int64); ok {
		r0 = returnFunc(r)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(io.Reader) error); ok {
		r1 = returnFunc(r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockwriter_ReadFrom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadFrom'
type mockwriter_ReadFrom_Call struct {
	*mock.Call
}

// ReadFrom is a helper method to define mock.On call
//   - r io.Reader
func (_e *mockwriter_Expecter) ReadFrom(r interface{}) *mockwriter_ReadFrom_Call {
	return &mockwriter_ReadFrom_Call{Call: _e.mock.On("ReadFrom", r)}
}

func (_c *mockwriter_ReadFrom_Call) Run(run func(r io.Reader)) *mockwriter_ReadFrom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 io.Reader
		if args[0] != nil {
			arg0 = args[0].(io.Reader)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mockwriter_ReadFrom_Call) Return(n int64, err error) *mockwriter_ReadFrom_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *mockwriter_ReadFrom_Call) RunAndReturn(run func(r io.Reader) (int64, error)) *mockwriter_ReadFrom_Call {
	_c.Call.Return(run)
	return _c
}

// Write provides a mock function for the type mockwriter
func (_mock *mockwriter) Write(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Write")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockwriter_Write_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Write'
type mockwriter_Write_Call struct {
	*mock.Call
}

// Write is a helper method to define mock.On call
//   - p []byte
func (_e *mockwriter_Expecter) Write(p interface{}) *mockwriter_Write_Call {
	return &mockwriter_Write_Call{Call: _e.mock.On("Write", p)}
}

func (_c *mockwriter_Write_Call) Run(run func(p []byte)) *mockwriter_Write_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mockwriter_Write_Call) Return(n int, err error) *mockwriter_Write_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *mockwriter_Write_Call) RunAndReturn(run func(p []byte) (int, error)) *mockwriter_Write_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockWriterPro creates a new instance of MockWriterPro. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockWriterPro(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockWriterPro {
	mock := &MockWriterPro{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockWriterPro is an autogenerated mock type for the WriterPro type
type MockWriterPro struct {
	mock.Mock
}

type MockWriterPro_Expecter struct {
	mock *mock.Mock
}

func (_m *MockWriterPro) EXPECT() *MockWriterPro_Expecter {
	return &MockWriterPro_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type MockWriterPro
func (_mock *MockWriterPro) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockWriterPro_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockWriterPro_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockWriterPro_Expecter) Close() *MockWriterPro_Close_Call {
	return &MockWriterPro_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockWriterPro_Close_Call) Run(run func()) *MockWriterPro_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWriterPro_Close_Call) Return(err error) *MockWriterPro_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockWriterPro_Close_Call) RunAndReturn(run func() error) *MockWriterPro_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Flush provides a mock function for the type MockWriterPro
func (_mock *MockWriterPro) Flush() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Flush")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockWriterPro_Flush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Flush'
type MockWriterPro_Flush_Call struct {
	*mock.Call
}

// Flush is a helper method to define mock.On call
func (_e *MockWriterPro_Expecter) Flush() *MockWriterPro_Flush_Call {
	return &MockWriterPro_Flush_Call{Call: _e.mock.On("Flush")}
}

func (_c *MockWriterPro_Flush_Call) Run(run func()) *MockWriterPro_Flush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWriterPro_Flush_Call) Return(err error) *MockWriterPro_Flush_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockWriterPro_Flush_Call) RunAndReturn(run func() error) *MockWriterPro_Flush_Call {
	_c.Call.Return(run)
	return _c
}

// ReadFrom provides a mock function for the type MockWriterPro
func (_mock *MockWriterPro) ReadFrom(r io.Reader) (int64, error) {
	ret := _mock.Called(r)

	if len(ret) == 0 {
		panic("no return value specified for ReadFrom")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(io.Reader) (int64, error)); ok {
		return returnFunc(r)
	}
	if returnFunc, ok := ret.Get(0).(func(io.Reader) int64); ok {
		r0 = returnFunc(r)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(io.Reader) error); ok {
		r1 = returnFunc(r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWriterPro_ReadFrom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadFrom'
type MockWriterPro_ReadFrom_Call struct {
	*mock.Call
}

// ReadFrom is a helper method to define mock.On call
//   - r io.Reader
func (_e *MockWriterPro_Expecter) ReadFrom(r interface{}) *MockWriterPro_ReadFrom_Call {
	return &MockWriterPro_ReadFrom_Call{Call: _e.mock.On("ReadFrom", r)}
}

func (_c *MockWriterPro_ReadFrom_Call) Run(run func(r io.Reader)) *MockWriterPro_ReadFrom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 io.Reader
		if args[0] != nil {
			arg0 = args[0].(io.Reader)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockWriterPro_ReadFrom_Call) Return(n int64, err error) *MockWriterPro_ReadFrom_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockWriterPro_ReadFrom_Call) RunAndReturn(run func(r io.Reader) (int64, error)) *MockWriterPro_ReadFrom_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type MockWriterPro
func (_mock *MockWriterPro) Size() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// MockWriterPro_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type MockWriterPro_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *MockWriterPro_Expecter) Size() *MockWriterPro_Size_Call {
	return &MockWriterPro_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *MockWriterPro_Size_Call) Run(run func()) *MockWriterPro_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWriterPro_Size_Call) Return(n int) *MockWriterPro_Size_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MockWriterPro_Size_Call) RunAndReturn(run func() int) *MockWriterPro_Size_Call {
	_c.Call.Return(run)
	return _c
}

// Write provides a mock function for the type MockWriterPro
func (_mock *MockWriterPro) Write(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Write")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWriterPro_Write_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Write'
type MockWriterPro_Write_Call struct {
	*mock.Call
}

// Write is a helper method to define mock.On call
//   - p []byte
func (_e *MockWriterPro_Expecter) Write(p interface{}) *MockWriterPro_Write_Call {
	return &MockWriterPro_Write_Call{Call: _e.mock.On("Write", p)}
}

func (_c *MockWriterPro_Write_Call) Run(run func(p []byte)) *MockWriterPro_Write_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockWriterPro_Write_Call) Return(n int, err error) *MockWriterPro_Write_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockWriterPro_Write_Call) RunAndReturn(run func(p []byte) (int, error)) *MockWriterPro_Write_Call {
	_c.Call.Return(run)
	return _c
}

// WriteByte provides a mock function for the type MockWriterPro
func (_mock *MockWriterPro) WriteByte(c byte) error {
	ret := _mock.Called(c)

	if len(ret) == 0 {
		panic("no return value specified for WriteByte")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(byte) error); ok {
		r0 = returnFunc(c)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockWriterPro_WriteByte_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteByte'
type MockWriterPro_WriteByte_Call struct {
	*mock.Call
}

// WriteByte is a helper method to define mock.On call
//   - c byte
func (_e *MockWriterPro_Expecter) WriteByte(c interface{}) *MockWriterPro_WriteByte_Call {
	return &MockWriterPro_WriteByte_Call{Call: _e.mock.On("WriteByte", c)}
}

func (_c *MockWriterPro_WriteByte_Call) Run(run func(c byte)) *MockWriterPro_WriteByte_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 byte
		if args[0] != nil {
			arg0 = args[0].(byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockWriterPro_WriteByte_Call) Return(err error) *MockWriterPro_WriteByte_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockWriterPro_WriteByte_Call) RunAndReturn(run func(c byte) error) *MockWriterPro_WriteByte_Call {
	_c.Call.Return(run)
	return _c
}

// WriteString provides a mock function for the type MockWriterPro
func (_mock *MockWriterPro) WriteString(s string) (int, error) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for WriteString")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (int, error)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) int); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWriterPro_WriteString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteString'
type MockWriterPro_WriteString_Call struct {
	*mock.Call
}

// WriteString is a helper method to define mock.On call
//   - s string
func (_e *MockWriterPro_Expecter) WriteString(s interface{}) *MockWriterPro_WriteString_Call {
	return &MockWriterPro_WriteString_Call{Call: _e.mock.On("WriteString", s)}
}

func (_c *MockWriterPro_WriteString_Call) Run(run func(s string)) *MockWriterPro_WriteString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockWriterPro_WriteString_Call) Return(n int, err error) *MockWriterPro_WriteString_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockWriterPro_WriteString_Call) RunAndReturn(run func(s string) (int, error)) *MockWriterPro_WriteString_Call {
	_c.Call.Return(run)
	return _c
}
